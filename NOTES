Feb 25, 2026:

I am now using a more general filtering language everywhere.  It's a bit
slower in some cases, but it's much more flexible and allows easy
command-line filter expressions.

As part of this work, I have been doing some simple performance measurements
between binary and text log files.  As expected, reading the text files with
the istream input operator is much slower than reading the binary files.
In fact it's almost exactly 20 times slower on my Mac Studio M1 Ultra.
From binary files, I can read about 5.3 million Messages per second.  From
the text files, it's around 260,000 Messages per second.

While I think it's good to have support for the text files, I'm
starting to think I don't want them as the default mclogd output.
Further, I might not want them as mclogd output at all.  How did I
reach this conclusion?

Well, if I always use binary files, 'mclog' can just as easily read from
the archived log files (.bz2 and .gz) as it can the current log file,
since I have support for compressed files in the Message class.  And it
can assume how to read the file based on the extension (or probe the
file by trying to read from it, though that isn't fun or fast).

But if I continue to support text files, I probably need to write a
lexer+parser for them.  I suspect much of the time consumption of the
istream input operators is in the timestamp parsing.  Of course I don't
expect any massive speedups; searching for terminals one byte at a time
as is necessary for processing a text file is inherently much slower
than reading blobs of known length from the binary files.  The timestamp
might not actually be the worst offender; it is fixed width so I read it
into a fixed-size buffer.  But I then use sscanf() and timegm() and some
sanity checking and basic arithmetic to get the final result (microseconds
since the UNIX Epoch).  But that's the thing; the binary file has the
timestamp as the microseconds since the UNIX Epoch in native form (well,
as an EncodedU64).  At most, a 9 byte encoding (1 byte for flags/length,
8 bytes for the value).  The text file requires 31 bytes for the timestamp
string.  The binary files use native single-byte encodings for facility
and severity, instead of strings.  The strings in the binary files are
length-encoded, and hence can be read without hunting for terminals (space,
newline, etc.).

#------------------------------------------------------------------------------
Feb 19, 2026:

Now that I have bzip2 and gzip I/O, I'd like to have a more general filtering
language that could be leveraged against log files that use the binary format
of Message (or the compressed binary format).  Of course I have yet to add the
option of binary log file output to mclogd, but it's not difficult.

field operands    valid operators
--------------    ---------------
  host            = != rgx
  ident           = != rgx
  facility        = != rgx
  severity        = != < <= > >=
  timestamp       < <= > >=

binary operators: || &&
unary operators:  !
grouping:         ( )

This would allow filtering statements such as:

  (host rgx ".*\.(mcplex\.net|rfdm\.com)") && (facility = local0)

  (ident = "mcroverd") && (severity > debug)

Note that the 'rgx' operator is a pessimistic optimization.  Since I'm
doing a full match of the expression, technically I could just always
use a regex.  However, regular expressions are considerably slower
than plain string comparisons, so I want to allow '=' and '!=' for
string comparisons.

HOST EQUAL STRING
HOST NOTEQUAL STRING
HOST RGX STRING
IDENT EQUAL STRING
IDENT NOTEQUAL STRING
IDENT RGX STRING
FACILITY ???
SEVERITY EQUAL Severity
SEVERITY NOTEQUAL Severity
SEVERITY GREATERTHAN Severity
SEVERITY LESSTHAN Severity
SEVERITY GREATEROREQ Severity
SEVERITY LESSOREQ Severity

#------------------------------------------------------------------------------
Feb 8, 2026:

I need to address the problem with FileLogger allowing multiple ofstreams
to be open for the same file.  When I migrated to having a vector of
filters, I didn't properly address the changes needed.  I need a many
to one mapping of filters to log files.  While there isn't any true harm
with the way things work today, it can mean duplicate entries in log files
and conflicts with permissions and roll period.

It's not so hard to solve the issue of multiple ofstreams open for the
same file.  However, I don't have an easy fix yet for the permission
and roll period conflicts.  The good news is that this only happens if
more than one filter points to the same logfile path.  This would not
be normal for my usage, and is mostly avoidable using the filter
language.  However, it's still an issue I should fix.

Solved Feb 11, 2026.

#------------------------------------------------------------------------------
Feb 7, 2026:

I need to split Logger to allow the user to specify message sinks.  By
default, it should use what it uses today: send to loopback via UDP.
But it should be possible to specify sinks instead.  This would allow
mclogd, for example, to use Logger to directly send to multicast or
files instead of a circuitous route through the loopback (which depends
on the LoopbackReceiver thread being active).

On output I need to separate direct I/O from threads that queue messages
for I/O.  This would allow mclogd to directly log to files or multicast
when stopping or starting threads that normally process log messages.

Logger is now a singleton, but that could change in the future.  The
only real process-wide resource concern with multiple Logger instances
at the moment is open UDP sockets.  A few is no big deal.  Hundreds
would be bad.

#------------------------------------------------------------------------------
Feb 6, 2026: I don't like the Logger implementation, with all static members.
It doesn't let me control destruction (flush queued messages, for example).
It could be a singleton, though I've never been a big fan of that pattern if
it's avoidable.
#------------------------------------------------------------------------------
Feb 6, 2026: I don't really need this, since it can be accomplished with
filtering.

I need a routing configuration so I can specify whether or not to forward:

  - local messages (received on loopback) to files
  - local messages (received on loopback) to multicast
  - multicast messages (sent to group from others) to files

#------------------------------------------------------------------------------
#  Filtering (work started in Mclog::MessageSelector)
#  I think I'm done with this as of Feb 4, 2026
#------------------------------------------------------------------------------
I need a filtering config that allows message selection, so I can configure
file output and also what gets sent via the aforementioned routing.  Message
selection:

  - source host
  - facility
  - minimum severity
  - ident

Source host:
  - should probably be a regular expression.
Facility:
  - list of facilities, or empty (empty means all)
Minimum severity:
  - textual representation of minimum priority (Mclog::Severity)
ident:
  - regular expression to match appname in MessageOrigin

What a filter might look like in config:

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  }

Or:

  everything = {
    host = ".+";
    facility = "";
    minimumSeverity = debug;
    ident = ! "Test.*";
  }

Internal representation:
  - sourceHostrgx: std::regex, default std::regex(".*")
  - facility: std::set<Mclog::Facility>, default empty set
  - minimumSeverity: Mclog::Severity, default Mclog::Severity::debug
  - identrgx: std::regex, default std::regex(".*")

And the matching logic:
  - _sourceHost.second == regex_match(msg.Origin().hostname(), sm, _sourceHost.first)
  - _facilities.empty() || (_facilities.find(msg.Header().facility()) != _facilities.end())
  - msg.Header().severity() <= _minimumSeverity
  - _ident.second == (regex_match(msg.Origin().appname(), sm, _ident.first)

I added negative logic handling for sourceHostrgx, facility and identrgx.

So if I have a selectors section in the config, I should be able to reference
another selector when configuring a selector:

selectors {

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  };

  notmydaemons = ! mydaemons;
  
};

Of course this means I need to specify a filtering language.  It's on the
todo list, but what operators do I need?

  !
  &&
  ||
  ()

This is all boolean logic.

The grammar would look something like:

%union {
  bool          boolVal;
  std::string  *stringVal;
}

%type <boolVal> Filter Selector

Filter:
    Selector            { $$ = $1; }
    | '!' Filter        { $$ = (! $1); }
    | Filter OR Filter  { $$ = ($1 || $3); }
    | Filter AND Filter { $$ = ($1 && $3); }
    | '(' Filter ')'    { $$ = $2; };
    
Selector: STRING
{
    auto it = g_selectors.find(*$1);
    if (it != g_selectors.end()) {
      $$ = it->second(msg);
    }
    else {
      $$ = false;
    }
    delete $1;
};

