#------------------------------------------------------------------------------
Feb 7, 2026:

I need to split Logger to allow the user to specify message sinks.  By
default, it should use what it uses today: send to loopback via UDP.
But it should be possible to specy sinks instead.  This would allow
mclogd, for example, to use Logger to directly send to multicast or
files instead of a circuitous route through the loopback (which depends
on the LoopbackReceiver thread being active).

On output I need to separate direct I/O from threads that queue messages
for I/O.  This would allow mclogd to directly log to files or multicast
when stopping or starting threads that normally process log messages.

Logger is now a singleton, but that could change in the future.  The
only real process-wide resource concern with multiple Logger instances
at the moment is open UDP sockets.  A few is no big deal.  Hundreds
would be bad.

#------------------------------------------------------------------------------
Feb 6, 2026: I don't like the Logger implementation, with all static members.
It doesn't let me control destruction (flush queued messages, for example).
It could be a singleton, though I've never been a big fan of that pattern if
it's avoidable.
#------------------------------------------------------------------------------
Feb 6, 2026: I don't really need this, since it can be accomplished with
filtering.

I need a routing configuration so I can specify whether or not to forward:

  - local messages (received on loopback) to files
  - local messages (received on loopback) to multicast
  - multicast messages (sent to group from others) to files

#------------------------------------------------------------------------------
#  Filtering (work started in Mclog::MessageSelector)
#  I think I'm done with this as of Feb 4, 2026
#------------------------------------------------------------------------------
I need a filtering config that allows message selection, so I can configure
file output and also what gets sent via the aforementioned routing.  Message
selection:

  - source host
  - facility
  - minimum severity
  - ident

Source host:
  - should probably be a regular expression.
Facility:
  - list of facilities, or empty (empty means all)
Minimum severity:
  - textual representation of minimum priority (Mclog::Severity)
ident:
  - regular expression to match appname in MessageOrigin

What a filter might look like in config:

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  }

Or:

  everything = {
    host = ".+";
    facility = "";
    minimumSeverity = debug;
    ident = ! "Test.*";
  }

Internal representation:
  - sourceHostrgx: std::regex, default std::regex(".*")
  - facility: std::set<Mclog::Facility>, default empty set
  - minimumSeverity: Mclog::Severity, default Mclog::Severity::debug
  - identrgx: std::regex, default std::regex(".*")

And the matching logic:
  - _sourceHost.second == regex_match(msg.Origin().hostname(), sm, _sourceHost.first)
  - _facilities.empty() || (_facilities.find(msg.Header().facility()) != _facilities.end())
  - msg.Header().severity() <= _minimumSeverity
  - _ident.second == (regex_match(msg.Origin().appname(), sm, _ident.first)

I added negative logic handling for sourceHostrgx, facility and identrgx.

So if I have a selectors section in the config, I should be able to reference
another selector when configuring a selector:

selectors {

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  };

  notmydaemons = ! mydaemons;
  
};

Of course this means I need to specify a filtering language.  It's on the
todo list, but what operators do I need?

  !
  &&
  ||
  ()

This is all boolean logic.

The grammar would look something like:

%union {
  bool          boolVal;
  std::string  *stringVal;
}

%type <boolVal> Filter Selector

Filter:
    Selector            { $$ = $1; }
    | '!' Filter        { $$ = (! $1); }
    | Filter OR Filter  { $$ = ($1 || $3); }
    | Filter AND Filter { $$ = ($1 && $3); }
    | '(' Filter ')'    { $$ = $2; };
    
Selector: STRING
{
    auto it = g_selectors.find(*$1);
    if (it != g_selectors.end()) {
      $$ = it->second(msg);
    }
    else {
      $$ = false;
    }
    delete $1;
};

