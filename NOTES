Feb 8, 2026:

I need to address the problem with FileLogger allowing multiple ofstreams
to be open for the same file.  When I migrated to having a vector of
filters, I didn't properly address the changes needed.  I need a many
to one mapping of filters to log files.  While there isn't any true harm
with the way things work today, it can mean duplicate entries in log files
and conflicts with permissions and roll period.

It's not so hard to solve the issue of multiple ofstreams open for the
same file.  However, I don't have an easy fix yet for the permission
and roll period conflicts.  The good news is that this only happens if
more than one filter points to the same logfile path.  This would not
be normal for my usage, and is mostly avoidable using the filter
language.  However, it's still an issue I should fix.

What I need is a function that returns a set of unique log paths we
want to log to, so I can have:

  map<string,LogFile>  _logFiles;

And for a given message and configuration, a function that returns the set of
unique paths we want to update.  e.g.:

  GetLogPaths(??? , Message & msg, set<string> & logPaths);


#------------------------------------------------------------------------------
Feb 7, 2026:

I need to split Logger to allow the user to specify message sinks.  By
default, it should use what it uses today: send to loopback via UDP.
But it should be possible to specy sinks instead.  This would allow
mclogd, for example, to use Logger to directly send to multicast or
files instead of a circuitous route through the loopback (which depends
on the LoopbackReceiver thread being active).

On output I need to separate direct I/O from threads that queue messages
for I/O.  This would allow mclogd to directly log to files or multicast
when stopping or starting threads that normally process log messages.

Logger is now a singleton, but that could change in the future.  The
only real process-wide resource concern with multiple Logger instances
at the moment is open UDP sockets.  A few is no big deal.  Hundreds
would be bad.

#------------------------------------------------------------------------------
Feb 6, 2026: I don't like the Logger implementation, with all static members.
It doesn't let me control destruction (flush queued messages, for example).
It could be a singleton, though I've never been a big fan of that pattern if
it's avoidable.
#------------------------------------------------------------------------------
Feb 6, 2026: I don't really need this, since it can be accomplished with
filtering.

I need a routing configuration so I can specify whether or not to forward:

  - local messages (received on loopback) to files
  - local messages (received on loopback) to multicast
  - multicast messages (sent to group from others) to files

#------------------------------------------------------------------------------
#  Filtering (work started in Mclog::MessageSelector)
#  I think I'm done with this as of Feb 4, 2026
#------------------------------------------------------------------------------
I need a filtering config that allows message selection, so I can configure
file output and also what gets sent via the aforementioned routing.  Message
selection:

  - source host
  - facility
  - minimum severity
  - ident

Source host:
  - should probably be a regular expression.
Facility:
  - list of facilities, or empty (empty means all)
Minimum severity:
  - textual representation of minimum priority (Mclog::Severity)
ident:
  - regular expression to match appname in MessageOrigin

What a filter might look like in config:

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  }

Or:

  everything = {
    host = ".+";
    facility = "";
    minimumSeverity = debug;
    ident = ! "Test.*";
  }

Internal representation:
  - sourceHostrgx: std::regex, default std::regex(".*")
  - facility: std::set<Mclog::Facility>, default empty set
  - minimumSeverity: Mclog::Severity, default Mclog::Severity::debug
  - identrgx: std::regex, default std::regex(".*")

And the matching logic:
  - _sourceHost.second == regex_match(msg.Origin().hostname(), sm, _sourceHost.first)
  - _facilities.empty() || (_facilities.find(msg.Header().facility()) != _facilities.end())
  - msg.Header().severity() <= _minimumSeverity
  - _ident.second == (regex_match(msg.Origin().appname(), sm, _ident.first)

I added negative logic handling for sourceHostrgx, facility and identrgx.

So if I have a selectors section in the config, I should be able to reference
another selector when configuring a selector:

selectors {

  mydaemons = {
    host = ".+\.(mcplex\.net|rfdm\.com)";
    facility = "";
    minimumSeverity = info;
    ident = "mcroverd|mctallyd|mccurtaind|mcblockd";
  };

  notmydaemons = ! mydaemons;
  
};

Of course this means I need to specify a filtering language.  It's on the
todo list, but what operators do I need?

  !
  &&
  ||
  ()

This is all boolean logic.

The grammar would look something like:

%union {
  bool          boolVal;
  std::string  *stringVal;
}

%type <boolVal> Filter Selector

Filter:
    Selector            { $$ = $1; }
    | '!' Filter        { $$ = (! $1); }
    | Filter OR Filter  { $$ = ($1 || $3); }
    | Filter AND Filter { $$ = ($1 && $3); }
    | '(' Filter ')'    { $$ = $2; };
    
Selector: STRING
{
    auto it = g_selectors.find(*$1);
    if (it != g_selectors.end()) {
      $$ = it->second(msg);
    }
    else {
      $$ = false;
    }
    delete $1;
};

